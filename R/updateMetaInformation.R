#' Update Meta Information Records
#' 
#' When a time series is stored to the database by \code{\link{storeTimeSeries}} 
#' a minimal unlocalized (i.e. untranslatable) meta information record is being 
#' generated. This meta information can be supplement using the updateMetaInformation
#' methods. Depending on the class of the environment that holds the
#' meta information localized or unlocalized meta information is updated. 
#' NOTE: AVOID looping over this function. This functions accepts entire environments
#' and creates large SQL queries instead of looping over multiple small queries. 
#' In other words loops are moved to the databse level for massive speed gain. 
#' 
#' @param meta_envir object of class meta_env. Most likely
#' generated by \code{\link{addMetaInformation}}
#' @param con a PostgreSQL connection object
#' @param schema character name of the schema to write to. Defaults to 'timeseries'.
#' @param tbl character name of the meta information table to write to. 
#' Defaults to 'meta_data_unlocalized'.
#' @param locale character iso 2 digit locae description. Defaults to NULL.
#' @param keys character vector of time series. If specified only the selected 
#' meta information is stored. Defaults to NULL which stores all meta information
#' records in the environment.
#' @param quiet logical should function be quiet instead of returning a message when done? Defaults to FALSE.  
#' @export
updateMetaInformation <- function(meta_envir,con,
                          schema = "timeseries",
                          tbl = "meta_data_unlocalized",
                          locale = NULL,
                          keys = NULL,
                          quiet = F) {
  UseMethod("updateMetaInformation")
} 


#' @rdname updateMetaInformation
#' @export
updateMetaInformation.meta_env <- function(meta_envir,con,
                                           schema = "timeseries",
                                           tbl = "meta_data_unlocalized",
                                           locale = NULL,
                                           keys = NULL,
                                           quiet = F){
  
  l <- as.list(meta_envir)
  
  # specification of keys can be used
  # to only store selected parts of the
  # meta infomration environment
  if(!is.null(keys)){
    l <- l[keys]  
  }
 
  # Minimal sanitizer to avoid trouble
  # when meta information gets too crazy... maybe need to escape things.
  # Did you really name your son Robert); DROP table students?
  l <- lapply(l,function(x){
    san <- lapply(x,gsub,pattern="'|DROP|DELETE|UPDATE|SELECT",
                  replacement="",ignore.case = T)
    class(san) <- c('miro','list')
    san
  })
  
  
  hstores <- lapply(l,createHstore)
  tbl <- paste(schema,tbl,sep=".")
  series <- names(l)
  
  if(is.null(locale)){
    md_df <- data.frame(ts_key = names(hstores),
                        meta_data = unlist(hstores),
                        stringsAsFactors = F)

    query_meta_data_insert <- sprintf("BEGIN;
                              CREATE TEMPORARY TABLE 
                              md_updates(ts_key varchar, meta_data hstore) ON COMMIT DROP;
                              COPY md_updates FROM STDIN;")

    query_meta_data_update <- sprintf("LOCK TABLE %s IN EXCLUSIVE MODE;
                                      UPDATE %s
                                      SET meta_data = md_updates.meta_data
                                      FROM md_updates
                                      WHERE md_updates.ts_key = %s.ts_key;
                                      COMMIT;",
                                      tbl,
                                      tbl,
                                      tbl)
    } else {
    md_df <- data.frame(ts_key = names(hstores),
                        locale = locale,
                        meta_data = unlist(hstores),
                        stringsAsFactors = F)
    
    query_meta_data_insert <- sprintf("BEGIN;
                              CREATE TEMPORARY TABLE 
                              md_updates(ts_key varchar, locale varchar,
                                         meta_data hstore) ON COMMIT DROP;
                              COPY md_updates FROM STDIN;")
    
    # localized meta information does not HAVE to exist, which 
    # means we have to have an insert here!  
    query_meta_data_update <- sprintf("LOCK TABLE %s IN EXCLUSIVE MODE;
                                      UPDATE %s
                                      SET meta_data = md_updates.meta_data,
                                      locale_info = md_updates.locale
                                      FROM md_updates
                                      WHERE md_updates.ts_key = %s.ts_key
                                      AND md_updates.locale = %s.locale_info;
                                      
                                      ---
                                      INSERT INTO %s
                                      SELECT md_updates.ts_key,
                                      md_updates.locale,
                                      md_updates.meta_data
                                      FROM md_updates
                                      LEFT OUTER JOIN %s 
                                      ON %s.ts_key = md_updates.ts_key
                                      AND %s.locale_info = md_updates.locale
                                      WHERE %s.ts_key IS NULL 
                                      AND %s.locale_info IS NULL;
                                      COMMIT;",
                                      tbl, tbl, tbl, tbl,
                                      tbl, tbl, tbl, tbl, tbl, tbl)
  }
  
  class(query_meta_data_update) <- "SQL"
  class(query_meta_data_insert) <- "SQL"
  
  md_ok <- DBI::dbGetQuery(con,query_meta_data_insert)
  postgresqlCopyInDataframe(con, md_df)
  md_ok2 <- DBI::dbGetQuery(con,query_meta_data_update)
  if(!quiet) {
    if(is.null(md_ok2)) cat("Meta information updated.")  
  }
  
}
